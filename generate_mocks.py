import itertools
import numpy as np
import healpy as hp
from pathlib import Path

import dipole
from multipoles import multipole_map

NSIDE = 64

def main():
    generate_mocks_from_cases()


def case_set():

    Cell_modes = ['zeros', 'flat', 'datalike']
    selfunc_modes = ['ones', 'binary', 'datasf']
    dipole_amps = [0.0, 0.007, 0.014]

    arrs = [Cell_modes, selfunc_modes, dipole_amps]
    cases = list(itertools.product(*arrs))

    case_dicts = []
    for case in cases:
        case_dict = {
            "Cell_mode": case[0],
            "selfunc_mode": case[1],
            "dipole_amp": case[2]
        }
        case_dicts.append(case_dict)

    return case_dicts


def get_payload(case_dict):
    payload_dict = {
        "Cells": get_cells(case_dict['Cell_mode']), # write this function!
        "selfunc": get_selfunc(case_dict['selfunc_mode']), # write this function!
        "dipole_amp": case_dict['dipole_amp']
    }
    return payload_dict


def generate_mocks_from_cases():

    dir_mocks = '../data/mocks'
    Path.mkdir(Path(dir_mocks), exist_ok=True, parents=True)

    case_dicts = case_set()
    n_trials_per_case = 12

    for case_dict in case_dicts:
        
        tag_case = f"_case{case_dict['Cell_mode']}-{case_dict['selfunc_mode']}-{case_dict['dipole_amp']}"
        payload = get_payload(case_dict) 

        for i in range(n_trials_per_case):

            mock = generate_mock(payload, trial=i) # or do you just want the case here and get payload inside genmock?

            fn_mock = f"{dir_mocks}/mock{tag_case}_trial{i}.npy"
            np.save(fn_mock, mock)


def generate_mock(payload, trial=0):
    return "i'm a mock!"

def generate_expected_dipole_map(dipole_amplitude, nside=NSIDE):
    """
    Parameters
    ----------
    dipole_amplitude : float
        The amplitude of the dipole in the normal convention (not the alm convention),
        depends on the number counts.
    """
    amps = np.zeros(4)
    amps[1:] = dipole.cmb_dipole(amplitude=dipole_amplitude, return_amps=True)
    return dipole.dipole_map(amps, NSIDE=nside)

def get_sph_harm_amp_dict(Cells, rng):
    """
    Parameters
    ----------
    Cells : ndarray, type float, shape (ellmax-1,)
        Cells for ell = 1, 2, ..., ellmax
        Note: 1-indexed
    """
    sph_harm_amp_dict = {}
    for ell in range(1, len(Cells)+1):
        sph_harm_amp_dict[ell] = np.sqrt(Cells[ell-1]) * rng.normal(size=2 * ell + 1)
    return sph_harm_amp_dict

def generate_smooth_overdensity_map(sph_harm_amp_dict, nside=NSIDE):
    """
    Parameters
    ----------
    sph_harm_amp_dict : dict
        Generated by get_sph_harm_amp_dict().
    nside : int, optional
    """
    mock_map = np.zeros((hp.nside2npix(nside)))
    for ell in sph_harm_amp_dict.keys():
        alms = sph_harm_amp_dict[ell]
        assert len(alms) == 2 * ell + 1, \
            f"incorrect number of coefficients for ell={ell} ({len(alms)}, expected {2 * ell + 1}"
        mock_map += multipole_map(alms)
    return mock_map

def generate_map(overdensity_map, base_rate, selfunc_map, rng):
    """
    Parameters
    ----------
    overdensity_map : healpix map
        Sum of expected dipole map and smooth_overdensity_map().
    base_rate : float
        Quasar rate per pixel in the overdensity=0, selection function=1 regions of the sky.
    selfunc_map : healpix map
        Selection function (mask or continuous).
    rng : numpy random number generator
    
    Bugs/Comments
    --------------
    - This function will only operate if there's a global variable called NSIDE.
    - If overdensity_map < -1 anywhere, this code will fail.
    """
    return rng.poisson((1. + overdensity_map) * base_rate * selfunc_map)


if __name__ == "__main__":
    main()